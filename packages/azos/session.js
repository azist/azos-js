/*<FILE_LICENSE>
 * Azos (A to Z Application Operating System) Framework
 * The A to Z Foundation (a.k.a. Azist) licenses this file to you under the MIT license.
 * See the LICENSE file in the project root for more information.
</FILE_LICENSE>*/

import * as types from "./types.js";
import * as aver from "./aver.js";
import { User } from "./security.js";
import { Application } from "./application.js";
import { AppSync, SYNC_EVT_TYPE_SESSION_CHANGE } from "./appsync.js";
import { IStorage } from "./storage.js";
import { LOG_TYPE } from "./log.js";


export const STORAGE_SESSION_KEY = "az-session";


/**
 * Session holds data about user session: user, culture, options etc.
 * An application chassis has a session, which represents default session for the whole
 * application, whereas on server "strides/threads" every flow of parallel execution may pass session
 * around as a reference.
 */
export class Session extends types.DisposableObject{
  #app;
  #user;
  #isoLang;
  #tzName;
  #theme;
  #culture;
  #settings;


  // eslint-disable-next-line no-unused-vars
  constructor(app, cfg = null){
    super();
    this.#app = aver.isOf(app, Application);
    this.#user = User.invalid;
  }

  [types.DESTRUCTOR_METHOD](){  }

  /** @returns {Application} */
  get app(){ return this.#app; }

  /**
   * Returns current session user. This property is never null because {@link User.invalid} is returned
   * when no specific user is set
   * @returns {User}
   */
  get user(){ return this.#user; }
  set user(usr){
    const was = this.#user;
    if (!types.isAssigned(usr)) usr = User.invalid;
    this.#user = aver.isOf(usr, User);

    if (this.#user !== was){ //Store local user and Broadcast change
      this.#storeUser(this.#user);
      //broadcast user change
      this.#broadcastSessionChange();
    }
  }

  get isoLang(){ return this.#isoLang; }
  set isoLang(v){ this.#isoLang = aver.isStringOrNull(v); }

  get theme(){ return this.#theme; }
  set theme(v){ this.#theme = aver.isStringOrNull(v); }

  /** TimeZone name. Null = UTC */
  get tzName(){ return this.#tzName; }
  set tzName(v){ this.#tzName = aver.isStringOrNull(v); }

  /**
   * Internal: Synchronizes this session with another one, e.g. from another browser tab.
   * The data parameter contains new principal/user
  */
  _sync(data){
    const init = data.user;
    if (!types.isObject(init)) return;
    this.#app.log.write({type: LOG_TYPE.INFO, from: "sess._sync()", text: "Sync user", params: init});
    const usr = new User(init);
    this.#user = usr;//notice assignment into pvt and no broadcast change

    this.#isoLang = data.isoLang;
    this.#theme = data.theme;
    this.#tzName = data.tzName;

    //TBD: We might need to rise event here about session change
  }

  #broadcastSessionChange(){
    const linker = this.#app.moduleLinker;
    const sync = linker.tryResolve(AppSync);
    if (sync !== null){
      this.#app.log.write({type: LOG_TYPE.INFO, from: "sess.change()", text: "Broadcast user change"});
      sync.postEvent(SYNC_EVT_TYPE_SESSION_CHANGE, {user: this.#user.toInitObject(), isoLang: this.#isoLang, theme: this.#theme});
    }
  }

  #storeUser(user){
    const storage = this.#app.moduleLinker.tryResolve(IStorage);
    if (storage === null) return;

    const ini = {
      expNowSec: (Date.now() / 1000) + (3 * 24 * 60 * 60),//todo: Move to setting/constant instead
      user: user.toInitObject()
    };

    storage.setItem(STORAGE_SESSION_KEY, JSON.stringify(ini));
  }

  /**
   * Usually called at/after application boot - initializes this session object using the
   * supplied INIT vector which contains  server-generated data which is typically pre-rendered
   * as a "&lt;script&gt;" block on the server. This block is generated by the server dynamically in response to successful
   * OAuth server-side redirect, when the server responds with a root SPA page.
   * The function first checks the `init` if it is supplied and valid, otherwise it tries to get a
   * stored state from the local storage.
   *
   * Single Page Applications (SPAs) maintain their own state including the user identity/access
   * in the session object. There is a special case of SPA boot-strapping as an app must know
   * its original user identity from the initial launch. This is applicable to authorization-code based OAuth 2
   * flows as "implicit" flows (when browser calls OAUth directly) are unsecure, we use full classical OAuth 2.
   * Upon a successful OAuth login, an authority redirects the browser to the relying party redirect URI which is
   * the server part of the SPA app being spawned on the client, so we need to pass original user/identity/token context
   * to the client SPA, so SPA can then obtain access tokens via original identity (usually a refresh token) which we need to supply at app launch.
   * This method is designed for just that - booting an application session in terms of identity.
   */
  boot(init){
    const LFROM ="sess.boot()";
    //1 - try to get init from storage
    let storage = null;
    if (!types.isObject(init)){
      storage = this.#app.moduleLinker.tryResolve(IStorage);
      if (storage === null) {
        this.#app.log.write({type: LOG_TYPE.WARNING, from: LFROM, text: "Exiting - no IStorage"});
        return;
      }
      try{
        const json = storage.getItem(STORAGE_SESSION_KEY);
        if (json) init = JSON.parse(json);
      }catch(e){
        this.#app.log.write({type: LOG_TYPE.ERROR, from: LFROM, text: `Storage load: ${e.message}`, exception: e});
        return;
      }
    }

    if (!types.isObject(init)) return;
    const expNow = 1000 * types.asInt(init.expNowSec);
    if (Date.now() > expNow){
      this.#app.log.write({type: LOG_TYPE.WARNING, from: LFROM, text: "User init expired"});
      if (storage !== null) storage.removeItem(STORAGE_SESSION_KEY);
      return;
    }

    //2 - read init
    const uini = init.user;
    if (!types.isAssigned(uini)) return;
    this.#app.log.write({type: LOG_TYPE.INFO, from: LFROM, text: "Initializing session user", params: uini});
    const usr = new User(uini);
    this.user = usr;
  }

}
