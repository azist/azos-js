/*<FILE_LICENSE>
 * Azos (A to Z Application Operating System) Framework
 * The A to Z Foundation (a.k.a. Azist) licenses this file to you under the MIT license.
 * See the LICENSE file in the project root for more information.
</FILE_LICENSE>*/

import * as types from "./types.js";
import * as aver from "./aver.js";
import { User } from "./security.js";
import { Application } from "./application.js";
import { AppSync, SYNC_EVT_TYPE_SESSION_CHANGE } from "./appsync.js";
import { IStorage } from "./storage.js";
import { LOG_TYPE } from "./log.js";


export const STORAGE_SESSION_KEY = "az-session";


/**
 * Session holds data about user session: user, culture, options etc.
 * An application chassis has a session, which represents default session for the whole
 * application, whereas on server "strides/threads" every flow of parallel execution may pass session
 * around as a reference.
 */
export class Session extends types.DisposableObject{
  #app;
  #user;
  #isoLang;
  #culture;
  #settings;

    //todo settings
  //todo culture...


  // eslint-disable-next-line no-unused-vars
  constructor(app, cfg=null){
    super();
    this.#app = aver.isOf(app, Application);
    this.#user = User.invalid;
  }

  [types.DESTRUCTOR_METHOD](){
  }

  /** @returns {Application} */
  get app(){ return this.#app; }

  /**
   * Returns current session user. This property is never null because {@link User.invalid} is returned
   * when no specific user is set
   * @returns {User}
   */
  get user(){ return this.#user; }
  set user(usr){
    const was = this.#user;
    if (!types.isAssigned(usr)) usr = User.invalid;
    this.#user = aver.isOf(usr, User);

    if (this.#user !== was){ //Store local user and Broadcast change
      this.#storeUser(this.#user);
      //broadcast user change
      this.#broadcastSessionChange();
    }
  }

  updateIdentity(refreshToken, jwt){
   // resolve event AppSync and broadcast an event
   this.#broadcastSessionChange();
  }

  /**
   * Synchronizes this session with another one, e.g. from another browser tab.
   * The data parameter contains new principal/user
  */
  _sync(data){
   //todo:  refreshToken and jwt need to be serialized
  }

  #broadcastSessionChange(){
    const linker = this.#app.moduleLinker;
    const sync = linker.tryResolve(AppSync);
    if (sync !== null){
      sync.postEvent(SYNC_EVT_TYPE_SESSION_CHANGE, {user: this.#user.toInitObject()});
    }
  }

  #storeUser(user){
    const storage = this.#app.moduleLinker.tryResolve(IStorage);
    if (storage === null) return;

    const ini = {
      expNow: Date.now() + (3 * 24 * 60 * 60 * 1000),//todo: Move to setting/constant instead
      user: user.toInitObject()
    };

    storage.setItem(STORAGE_SESSION_KEY, JSON.stringify(ini));
  }

  /**
   * Usually called at/after application boot - initializes this session object using the
   * supplied INIT vector which contains  server-generated data which is typically pre-rendered
   * as a "&lt;script&gt;" block on the server. This block is generated by the server dynamically in response to successful
   * OAuth server-side redirect, when the server responds with a root SPA page.
   * The function first checks the `init` if it is supplied and valid, otherwise it tries to get a
   * stored state from the local storage.
   *
   * Single Page Applications (SPAs) maintain their own state including the user identity/access
   * in the session object. There is a special case of SPA boot-strapping as an app must know
   * its original user identity from the initial launch. This is applicable to authorization-code based OAuth 2
   * flows as "implicit" flows (when browser calls OAUth directly) are unsecure, we use full classical OAuth 2.
   * Upon a successful OAuth login, an authority redirects the browser to the relying party redirect URI which is
   * the server part of the SPA app being spawned on the client, so we need to pass original user/identity/token context
   * to the client SPA, so SPA can then obtain access tokens via original identity (usually a refresh token) which we need to supply at app launch.
   * This method is designed for just that - booting an application session in terms of identity.
   */
  boot(init){
    //1 - try to get init from storage
    let storage = null;
    if (!types.isObject(init)){
      storage = this.#app.moduleLinker.tryResolve(IStorage);
      if (storage === null) return;
      init = storage.getItem(STORAGE_SESSION_KEY);
    }

    if (!types.isObject(init)) return;
    const expNow = 1000 * types.asInt(init.expNowSec);
    if (Date.now() > expNow){
      this.#app.log.write({type: LOG_TYPE.WARNING, text: "User init expired"});
      if (storage !== null) storage.removeItem(STORAGE_SESSION_KEY);
      return;
    }

    //2 - read init
    const uini = init.user;
    if (!types.isAssigned(uini)) return;
    this.#app.log.write({type: LOG_TYPE.INFO, text: "Initializing session user", params: uini});
    const usr = new User(uini);
    this.user = usr;
  }

}
